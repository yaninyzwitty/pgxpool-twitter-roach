package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"fmt"
	"log/slog"
	"strconv"
	"time"

	"github.com/yaninyzwitty/pgxpool-twitter-roach/graph/model"
	commentpb "github.com/yaninyzwitty/pgxpool-twitter-roach/shared/proto/comment"
	postpb "github.com/yaninyzwitty/pgxpool-twitter-roach/shared/proto/post"
	pb "github.com/yaninyzwitty/pgxpool-twitter-roach/shared/proto/user"
)

// User is the resolver for the user field.
func (r *commentResolver) User(ctx context.Context, obj *model.Comment) (*model.User, error) {
	if obj == nil || obj.User.ID == "" {
		return nil, fmt.Errorf("comment cant be empty")
	}
	userId, err := strconv.ParseInt(obj.User.ID, 10, 64)
	if err != nil {
		return nil, err
	}

	user, err := r.SocialServiceClient.GetUserById(ctx, &pb.GetUserByIdRequest{
		Id: userId,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get user by id: %w", err)

	}

	return &model.User{
		ID:        strconv.FormatInt(user.User.Id, 10),
		Username:  user.User.Username,
		Email:     user.User.Email,
		CreatedAt: user.User.UpdatedAt.AsTime(),
	}, nil

}

// User is the resolver for the user field.
func (r *postResolver) User(ctx context.Context, obj *model.Post) (*model.User, error) {

	if obj == nil || obj.User.ID == "" {
		return nil, fmt.Errorf("user cant be nil")
	}

	// userId, err := strconv.ParseInt(obj.User.ID, 10, 64)
	// if err != nil {
	// 	return nil, err
	// }
	// user, err := r.SocialServiceClient.GetUserById(ctx, &pb.GetUserByIdRequest{
	// 	Id: userId,
	// })
	// if err != nil {
	// 	return nil, fmt.Errorf("")
	// }
	return r.Query().GetUserByID(ctx, obj.User.ID)

}

// GetUserByID is the resolver for the getUserById field.
func (r *queryResolver) GetUserByID(ctx context.Context, id string) (*model.User, error) {
	if id == "" {
		return nil, fmt.Errorf("id cant be empty")
	}
	userId, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, err
	}

	result, err := r.SocialServiceClient.GetUserById(ctx, &pb.GetUserByIdRequest{
		Id: userId,
	})

	if err != nil {
		return nil, err
	}

	userIdInString := strconv.FormatInt(result.User.Id, 10)
	return &model.User{
		ID:        userIdInString,
		Username:  result.User.Username,
		Email:     result.User.Username,
		CreatedAt: result.User.UpdatedAt.AsTime(),
	}, nil
}

// GetUserByEmail is the resolver for the getUserByEmail field.
func (r *queryResolver) GetUserByEmail(ctx context.Context, email string) (*model.User, error) {
	if email == "" {
		return nil, fmt.Errorf("email cant be empty")
	}

	result, err := r.SocialServiceClient.GetUserByEmail(ctx, &pb.GetUserByEmailRequest{
		Email: email,
	})

	if err != nil {
		return nil, err
	}
	userIdInString := strconv.FormatInt(result.User.Id, 10)
	return &model.User{
		ID:        userIdInString,
		Username:  result.User.Username,
		Email:     result.User.Email,
		CreatedAt: result.User.UpdatedAt.AsTime(),
	}, nil
}

// GetUsers is the resolver for the getUsers field.
func (r *queryResolver) GetUsers(ctx context.Context, limit *int32, offset *int32) ([]*model.User, error) {
	// set default  limits
	l := int32(10)
	o := int32(0)

	if limit != nil {
		l = *limit
	}
	if offset != nil {
		o = *offset
	}

	response, err := r.SocialServiceClient.GetUsers(ctx, &pb.GetUsersRequest{
		Limit:  l,
		Offset: o,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to get users: %w", err)
	}

	var users []*model.User
	for _, u := range response.Users {
		userIdInString := strconv.FormatInt(u.Id, 10)
		users = append(users, &model.User{
			ID:        userIdInString,
			Username:  u.Username,
			Email:     u.Email,
			CreatedAt: u.UpdatedAt.AsTime(),
		})
	}

	return users, nil
}

// GetComment is the resolver for the getComment field.
func (r *queryResolver) GetComment(ctx context.Context, commentID string) (*model.Comment, error) {
	if commentID == "" {
		return nil, fmt.Errorf("commentID cant be empty")
	}

	commentId, err := strconv.ParseInt(commentID, 10, 64)
	if err != nil {
		return nil, err
	}

	response, err := r.CommentServiceClient.GetComment(ctx, &commentpb.GetCommentRequest{
		CommentId: commentId,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to get comment: %w", err)
	}

	updatedAt := response.Comment.UpdatedAt.AsTime()
	return &model.Comment{
		ID: strconv.FormatInt(response.Comment.Id, 10),
		User: &model.User{
			ID:        strconv.FormatInt(response.Comment.User.Id, 10),
			Username:  response.Comment.User.Username,
			Email:     response.Comment.User.Email,
			CreatedAt: response.Comment.User.UpdatedAt.AsTime(),
		},
		Body:      response.Comment.Body,
		CreatedAt: response.Comment.CreatedAt.AsTime(),
		PostID:    "",
		UpdatedAt: &updatedAt,
	}, nil
}

// GetPost is the resolver for the getPost field.
func (r *queryResolver) GetPost(ctx context.Context, postID string) (*model.Post, error) {
	if postID == "" {
		return nil, fmt.Errorf("postID cant be empty")
	}

	postId, err := strconv.ParseInt(postID, 10, 64)
	if err != nil {
		return nil, err
	}

	response, err := r.PostServiceClient.GetPost(ctx, &postpb.GetPostRequest{
		PostId: postId,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to get post: %w", err)
	}

	updatedAt := response.Post.UpdatedAt.AsTime()

	return &model.Post{
		ID: strconv.FormatInt(response.Post.Id, 10),
		User: &model.User{
			ID:        strconv.FormatInt(response.Post.User.Id, 10),
			Username:  response.Post.User.Username,
			Email:     response.Post.User.Email,
			CreatedAt: response.Post.User.UpdatedAt.AsTime(),
		},
		Body:      response.Post.Body,
		CreatedAt: response.Post.CreatedAt.AsTime(),
		UpdatedAt: &updatedAt,
		Comments:  nil,
	}, nil
}

// GetPosts is the resolver for the getPosts field.
func (r *queryResolver) GetPosts(ctx context.Context, limit *int32, offset *int32) ([]*model.Post, error) {
	return nil, nil
}

// StreamUsers is the resolver for the streamUsers field.
func (r *subscriptionResolver) StreamUsers(ctx context.Context, limit *int32) (<-chan *model.User, error) {
	l := int32(10)
	if limit != nil {
		l = *limit
	}

	userChan := make(chan *model.User)

	go func() {
		defer close(userChan)
		defer slog.Info("Closing user stream")

		ticker := time.NewTicker(2 * time.Second)
		defer ticker.Stop()

		for {
			select {
			case <-ctx.Done():
				slog.Info("Context cancelled", "reason", ctx.Err())
				return
			case <-ticker.C:
				// Get users in batches
				response, err := r.SocialServiceClient.GetUsers(ctx, &pb.GetUsersRequest{
					Limit:  l,
					Offset: 0, // You might want to implement pagination logic here
				})
				if err != nil {
					slog.Error("failed to get users", "error", err)
					return
				}

				// Send each user to the channel
				for _, u := range response.Users {
					select {
					case <-ctx.Done():
						return
					case userChan <- &model.User{
						ID:        strconv.FormatInt(u.Id, 10),
						Username:  u.Username,
						Email:     u.Email,
						CreatedAt: u.UpdatedAt.AsTime(),
					}:
						slog.Info("Sent user to channel", "id", u.Id)
					}
				}
			}
		}
	}()

	return userChan, nil
}

// Comment returns CommentResolver implementation.
func (r *Resolver) Comment() CommentResolver { return &commentResolver{r} }

// Post returns PostResolver implementation.
func (r *Resolver) Post() PostResolver { return &postResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type commentResolver struct{ *Resolver }
type postResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
