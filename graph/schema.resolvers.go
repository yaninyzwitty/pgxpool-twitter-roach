package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"fmt"
	"log/slog"
	"strconv"
	"time"

	"github.com/yaninyzwitty/pgxpool-twitter-roach/graph/model"
	pb "github.com/yaninyzwitty/pgxpool-twitter-roach/shared/proto/user"
)

// GetUserByID is the resolver for the getUserById field.
func (r *queryResolver) GetUserByID(ctx context.Context, id string) (*model.User, error) {
	if id == "" {
		return nil, fmt.Errorf("id cant be empty")
	}
	userId, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, err
	}

	result, err := r.SocialServiceClient.GetUserById(ctx, &pb.GetUserByIdRequest{
		Id: userId,
	})

	if err != nil {
		return nil, err
	}

	userIdInString := strconv.FormatInt(result.User.Id, 10)
	return &model.User{
		ID:        userIdInString,
		Username:  result.User.Username,
		Email:     result.User.Username,
		CreatedAt: result.User.UpdatedAt.AsTime(),
	}, nil
}

// GetUserByEmail is the resolver for the getUserByEmail field.
func (r *queryResolver) GetUserByEmail(ctx context.Context, email string) (*model.User, error) {
	if email == "" {
		return nil, fmt.Errorf("email cant be empty")
	}

	result, err := r.SocialServiceClient.GetUserByEmail(ctx, &pb.GetUserByEmailRequest{
		Email: email,
	})

	if err != nil {
		return nil, err
	}
	userIdInString := strconv.FormatInt(result.User.Id, 10)
	return &model.User{
		ID:        userIdInString,
		Username:  result.User.Username,
		Email:     result.User.Email,
		CreatedAt: result.User.UpdatedAt.AsTime(),
	}, nil
}

// GetUsers is the resolver for the getUsers field.
func (r *queryResolver) GetUsers(ctx context.Context, limit *int32, offset *int32) ([]*model.User, error) {
	// set default  limits
	l := int32(10)
	o := int32(0)

	if limit != nil {
		l = *limit
	}
	if offset != nil {
		o = *offset
	}

	response, err := r.SocialServiceClient.GetUsers(ctx, &pb.GetUsersRequest{
		Limit:  l,
		Offset: o,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to get users: %w", err)
	}

	var users []*model.User
	for _, u := range response.Users {
		userIdInString := strconv.FormatInt(u.Id, 10)
		users = append(users, &model.User{
			ID:        userIdInString,
			Username:  u.Username,
			Email:     u.Email,
			CreatedAt: u.UpdatedAt.AsTime(),
		})
	}

	return users, nil
}

// StreamUsers is the resolver for the streamUsers field.
func (r *subscriptionResolver) StreamUsers(ctx context.Context, limit *int32) (<-chan *model.User, error) {
	l := int32(10)
	if limit != nil {
		l = *limit
	}

	userChan := make(chan *model.User)

	go func() {
		defer close(userChan)
		defer slog.Info("Closing user stream")

		ticker := time.NewTicker(2 * time.Second)
		defer ticker.Stop()

		for {
			select {
			case <-ctx.Done():
				slog.Info("Context cancelled", "reason", ctx.Err())
				return
			case <-ticker.C:
				// Get users in batches
				response, err := r.SocialServiceClient.GetUsers(ctx, &pb.GetUsersRequest{
					Limit:  l,
					Offset: 0, // You might want to implement pagination logic here
				})
				if err != nil {
					slog.Error("failed to get users", "error", err)
					return
				}

				// Send each user to the channel
				for _, u := range response.Users {
					select {
					case <-ctx.Done():
						return
					case userChan <- &model.User{
						ID:        strconv.FormatInt(u.Id, 10),
						Username:  u.Username,
						Email:     u.Email,
						CreatedAt: u.UpdatedAt.AsTime(),
					}:
						slog.Info("Sent user to channel", "id", u.Id)
					}
				}
			}
		}
	}()

	return userChan, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
