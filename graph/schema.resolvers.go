package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"errors"
	"fmt"
	"io"
	"log/slog"
	"strconv"

	"github.com/yaninyzwitty/pgxpool-twitter-roach/graph/model"
	pb "github.com/yaninyzwitty/pgxpool-twitter-roach/shared/proto/user"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// GetUserByID is the resolver for the getUserById field.
func (r *queryResolver) GetUserByID(ctx context.Context, id string) (*model.User, error) {
	if id == "" {
		return nil, fmt.Errorf("id cant be empty")
	}
	userId, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, err
	}

	result, err := r.SocialServiceClient.GetUserById(ctx, &pb.GetUserByIdRequest{
		Id: userId,
	})

	if err != nil {
		return nil, err
	}

	userIdInString := strconv.FormatInt(result.User.Id, 10)
	return &model.User{
		ID:        userIdInString,
		Username:  result.User.Username,
		Email:     result.User.Username,
		CreatedAt: result.User.CreatedAt.AsTime(),
	}, nil
}

// GetUserByEmail is the resolver for the getUserByEmail field.
func (r *queryResolver) GetUserByEmail(ctx context.Context, email string) (*model.User, error) {
	if email == "" {
		return nil, fmt.Errorf("email cant be empty")
	}

	result, err := r.SocialServiceClient.GetUserByEmail(ctx, &pb.GetUserByEmailRequest{
		Email: email,
	})

	if err != nil {
		return nil, err
	}
	userIdInString := strconv.FormatInt(result.User.Id, 10)
	return &model.User{
		ID:        userIdInString,
		Username:  result.User.Username,
		Email:     result.User.Username,
		CreatedAt: result.User.CreatedAt.AsTime(),
	}, nil
}

// GetUsers is the resolver for the getUsers field.
func (r *queryResolver) GetUsers(ctx context.Context, limit *int32, offset *int32) ([]*model.User, error) {
	// set default  limits
	l := int32(10)
	o := int32(0)

	if limit != nil {
		l = *limit
	}
	if offset != nil {
		o = *offset
	}

	response, err := r.SocialServiceClient.GetUsers(ctx, &pb.GetUsersRequest{
		Limit:  l,
		Offset: o,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to get users: %w", err)
	}

	var users []*model.User
	for _, u := range response.Users {
		userIdInString := strconv.FormatInt(u.Id, 10)
		users = append(users, &model.User{
			ID:        userIdInString,
			Username:  u.Username,
			Email:     u.Email,
			CreatedAt: u.CreatedAt.AsTime(),
		})
	}

	return users, nil
}

// StreamUsers is the resolver for the streamUsers field.
func (r *subscriptionResolver) StreamUsers(ctx context.Context, limit *int32) (<-chan *model.User, error) {
	l := int32(10)
	if limit != nil {
		l = *limit
	}

	userChan := make(chan *model.User)

	stream, err := r.SocialServiceClient.StreamUsers(ctx, &pb.StreamUsersRequest{
		Limit: l,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to start user stream: %w", err)
	}

	go func() {
		defer close(userChan)
		defer slog.Info("Closing user stream")

		for {
			select {
			case <-ctx.Done():
				slog.Info("Context cancelled", "reason", ctx.Err())
				return
			default:
			}

			userResponse, err := stream.Recv()
			if err != nil {
				if errors.Is(err, io.EOF) {
					slog.Info("Stream ended normally")
					return
				}
				if status.Code(err) == codes.Canceled {
					slog.Info("Stream cancelled")
					return
				}
				slog.Error("stream error", "error", err)
				return
			}

			slog.Info("Received user", "id", userResponse.User.Id)

			select {
			case <-ctx.Done():
				return
			case userChan <- &model.User{
				ID:        strconv.FormatInt(userResponse.User.Id, 10),
				Username:  userResponse.User.Username,
				Email:     userResponse.User.Email,
				CreatedAt: userResponse.User.CreatedAt.AsTime(),
			}:
				slog.Info("Sent user to channel", "id", userResponse.User.Id)
			}
		}
	}()
	return userChan, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
